Nous avons extrait le code responsable de se connecter au serveur dans une
fonction Â«Â getSocketÂ Â». Celle-ci prend en argument les informations de connexion
(i.e. adresse IP et numÃ©ro de port) et retourne un socket ouvert. Nous en
profitons pour dÃ©finir un minuteur de 10 secondes aprÃ¨s lesquelles le socket
lancera une exception Â«Â SocketTimeoutExceptionÂ Â».

Le code principal utilise cette fonction pour se connecter au premier serveur
de la liste. Dans le cas oÃ¹ une exception de minuteur serait lancÃ©e, le code se
connecte aux serveur suivant dans la liste et recommence lÃ  oÃ¹ il Ã©tait rendu.
Pour ce faire, nous avons dÃ» placer l'instruction de l'utilisateur dans une
variable afin de pouvoir poursuivre sur la mÃªme instruction en cas de changement
de serveur.

Le code principal a Ã©tÃ© placÃ© dans une boucle qui continue tant que la tÃ¢che
n'est pas terminÃ©e et qu'il reste des serveurs auxquels tenter de se connecter.

La liste des serveurs est simplement passÃ©e au programme par les arguments de la
fonctions Â«Â mainÂ Â» sous la forme Â« ip:port Â» (e.g. client 127.0.0.1:1234
127.0.0.1:1234). Ce choix a Ã©tÃ© motivÃ© par la simplicitÃ© d'implÃ©mentation (i.e.
il est trÃ¨s simple d'avoir accÃ¨s aux arguments du programme), la simplicitÃ©
d'utilisation (i.e. il est trÃ¨s simple de fournir des arguments Ã  un exÃ©cutable) et
l'extensibilitÃ© (i.e. un nombre arbitraire de serveurs peut Ãªtre fourni).

De mettre les coordonnées en paramètre offre une certaine transparence d'accès, dans 
le sens où un serveur local peut être accédé de la même manière qu'un serveur distant.
De plus, ce choix a eu un grand impact sur la transparence de localisation: il est 
nécessaire de connaître les adresses des services pour s'y connecter. Par contre, 
notre choix n'a aucun impact sur la transparence de défaillance, de mobilité, 
d'extensibilité ou de performance; qu les coordonnées soient dans le programmes ou 
passées en argument, le programme demeure autant transparent d'une manière que de 
l'autre. 